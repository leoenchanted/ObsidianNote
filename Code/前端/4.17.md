# Collapse总结

方案一语义化很差 

```js
<collapse :item=items>
    </collapse>
```

所以选择方案二

```js
<collapse>
    <collapseItem name="a">
    </collapseItem>
</collapse>
```

数据状态以及处理放在父组件

使用provide/inject传递

v-model的实现 使用watch进行更新

内置transition实现动画效果 提供js钩子函数支持高级自定义功能   

# InheritAttrs

非prop的Attribute

比如父组件

```js
<MyButton type="select" value="shabi"></MyButton>
```

子组件

```js
<div>
    <Button v-bind="$attrs"></Button>
</div>

InherirAttrs:false
props:[value]
```

就是prop有value但是没有type  如果InherirAttrs:false没设置 我在父组件弄了type的话 他会自动放到div的根组件上，false就不会了 因为我想让他在button上 然后v-bind=attrs 就可以有 attrs就是不是props以及emits时间 但是传过来的属性！！！！（比如class 和Style啊这些）

# Icon组件总结

二次开发组件 对fontawesome

分两步走：

+ 支持组件的原始属性
  + inheritAttrs：false不继承属性
  + $attrs和$props
+ 扩充组件属性
  + 添加type/color属性
  + 过滤传递的属性lodash omit

#  CSS

## 盒子模型

标准盒子模型

- 盒子总宽度 = width + padding + border + margin;
- 盒子总高度 = height + padding + border + margin

也就是，`width/height` 只是内容高度，不包含 `padding` 和 `border`值

IE怪异盒子模型

`width/height` 包含了 `padding`和 `border`值

box-sizing

## 选择器

- id选择器（#box），选择id为box的元素
- 类选择器（.one），选择类名为one的所有元素
- 标签选择器（div），选择标签为div的所有元素
- 后代选择器（#box div），选择id为box元素内部所有的div元素
- 子选择器（.one>one_1），选择父元素为.one的所有.one_1的元素
- 相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素
- 群组选择器（div,p），选择div、p的所有元素

伪类选择器

伪元素选择器

属性选择器

css3新增的选择器

层次选择器

## 回流重绘

具体的浏览器解析渲染机制如下所示：

- 解析HTML，生成DOM树，解析CSS，生成CSSOM树

- 将DOM树和CSSOM树结合，生成渲染树(Render Tree)

- Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）

- Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素

- Display:将像素发送给GPU，展示在页面上

  当我们对 `DOM` 的修改引发了 `DOM`几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来

  当我们对 `DOM`的修改导致了样式的变化（`color`或`background-color`），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘

要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的

### 回流触发时机

回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
- 页面一开始渲染的时候（这避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

还有一些容易被忽略的操作：获取一些特定属性的值

> offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight

这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流

除此还包括`getComputedStyle`方法，原理是一样的

###  重绘触发时机

触发回流一定会触发重绘

可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）

除此之外还有一些其他引起重绘行为：

- 颜色的修改
- 文本方向的修改
- 阴影的修改

### 浏览器优化机制

由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列

当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的`offsetTop`等方法都会返回最新的数据

因此浏览器不得不清空队列，触发回流重绘来返回正确的值

## 预编译语言

sass、less、postcss