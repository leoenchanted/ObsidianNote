# Vue

## SPA（单页应用）的理解

通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（`HTML`、`JavaScript`和`CSS`）都通过单个页面的加载而检索

React Vue 都属于SPA

### SPA MPA

| SPA                                                          | MPA                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 速度快用户体验良好，但是不利于SEO 可以通过SSR改善 维护起来相对容易 | 对SEO友好，但是切换加载资源速度慢用户体验差，维护起来相对复杂 |

SSR服务端渲染，将组件或页面通过服务器生成html，再返回给浏览器 Nuxtjs Nextjs

## 生命周期

| activated     | keep-alive 缓存的组件激活时        |
| ------------- | ---------------------------------- |
| deactivated   | keep-alive 缓存的组件停用时调用    |
| errorCaptured | 捕获一个来自子孙组件的错误时被调用 |

### errorCaputred使用场景

假设有一个父组件，渲染一个子组件，这个子组件负责从一个api获取数据并在页面展示，但是由于其他问题，数据获取失败，如果不进行错误处理，会导致整个应用奔溃，用户体验非常糟糕 `return false` 防止错误继续向上冒泡

### keep-alive生命周期

`<keep-alive>` 是 Vue.js 提供的一个内置组件，用于**缓存不活动的组件实例**，而不是销毁它们

```html
<template>
  <div>
    <button @click="currentComponent = 'ComponentA'">显示 A</button>
    <button @click="currentComponent = 'ComponentB'">显示 B</button>

    <keep-alive>
      <component :is="currentComponent"></component>
    </keep-alive>
  </div>
</template>

<script>
import ComponentA from './ComponentA.vue';
import ComponentB from './ComponentB.vue';

export default {
  components: {
    ComponentA,
    ComponentB
  },
  data() {
    return {
      currentComponent: 'ComponentA'
    };
  }
};
</script>
```

在这个例子中，当 `currentComponent` 在 `ComponentA` 和 `ComponentB` 之间切换时，如果它们被 `<keep-alive>` 包裹，那么它们的状态（例如输入框中的内容、滚动位置等）会被保留。下次再切换回来时，组件会直接从缓存中恢复，而不会重新创建和渲染



`<keep-alive>` 组件还提供了一些可选的 props 来更精细地控制缓存行为：

- **`include` (string | RegExp | Array<string | RegExp>):** 只有名称匹配的组件会被缓存。可以是一个逗号分隔的字符串、一个正则表达式或一个字符串/正则表达式组成的数组。

- **`exclude` (string | RegExp | Array<string | RegExp>):** 任何名称匹配的组件都不会被缓存。同样可以是字符串、正则表达式或数组。

- **`max` (number):** 最多可以缓存多少个组件实例。一旦缓存的实例数量超过这个值，Vue 会销毁掉最久没有被访问的缓存组件。\

  ## 首屏加载

  首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间

常见的几种SPA首屏优化方式

- 减小入口文件积

  在`vue-router`配置路由的时候，采用动态加载路由的形式

  ```js
  routes:[ 
      path: 'Blogs',
      name: 'ShowBlogs',
      component: () => import('./components/ShowBlogs.vue')
  ]
  ```

  以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件

- 静态资源本地缓存

- UI框架按需加载

- 图片资源的压缩

  雪碧图

- 组件重复打包

  设`A.js`文件是一个常用的库，现在有多个路由使用了`A.js`文件，这就造成了重复下载

  解决方案：在`webpack`的`config`文件中，修改`CommonsChunkPlugin`的配置

  ```js
  minChunks: 3
  ```

  `minChunks`为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

- 开启GZip压缩

- 使用SSR

  ## 通信

  ### EventBus

  ## NextTick

  在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

## mixins

你可以将 Mixins 想象成一种“插件”或“特性包”，可以将一组特定的功能注入到多个组件中，而无需在每个组件中都重复编写相同的代码。这有助于提高代码的复用性和可维护性。

将一个公共逻辑写在一个mixin.js中，类似这样

```js
// myMixin.js
export default {
  data() {
    return {
      mixinData: 'This is from the mixin',
      sharedCount: 0
    };
  },
  methods: {
    mixinMethod() {
      console.log('Mixin method called');
      this.sharedCount++;
    }
  },
  created() {
    console.log('Mixin created hook called');
  }
};
```

```js
<script>
import myMixin from './myMixin.js';

export default {
  mixins: [myMixin],
  data() {
    return {
      componentData: 'This is from the component'
    };
  },
  methods: {
    componentMethod() {
      console.log('Component method called');
    }
  },
  created() {
    console.log('Component created hook called');
  }
};
</script>
```

## slot

占位符，可以后期使用标记语言填充

### 使用场景

可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理

通过`slot`插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用

### 分类

+ 默认插槽
+ 具名插槽
+ 作用域插槽

## Vue中key的原理

key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点

`key` 是 Vue 识别虚拟 DOM 节点身份的唯一标识符。

它帮助 Vue 更高效地进行 diff 算法，正确地识别和复用节点。

使用唯一的、稳定的 `key` 可以避免就地更新带来的状态错乱问题，尤其是在列表顺序可能改变的情况下。

避免使用索引作为 `key`，除非列表渲染顺序永远不变且没有内部状态需要维护。

`key` 也可以用于强制更新元素和触发过渡效果。

## vue修饰符

### 表单修饰符

v-model

+ lazy  在我们填完信息，光标离开标签的时候，才会将值赋予给`value`，也就是在`change`事件之后再进行信息同步

+ trim 自动过滤用户输入的首空格字符

+ number 自动将用户的输入值转为数值类型

  ### 事件修饰符

  - stop 阻止了事件冒泡

  - prevent 阻止了事件的默认行为

  - self

  - once 绑定了事件以后只能触发一次，第二次就不会触发

  - capture

  - passive

  - native 用于**监听组件根元素的原生 DOM 事件** 

    ## 自定义指令

    ### 全局注册

    全局注册主要是通过`Vue.directive`方法进行注册

`Vue.directive`第一个参数是指令的名字（不需要写上`v-`前缀），第二个参数可以是对象数据，也可以是一个指令函数

### 局部注册